'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true,
});
exports.LineChartContext = void 0;
exports.LineChartProvider = LineChartProvider;
var _react = _interopRequireWildcard(require('react'));
var _reactNativeReanimated = require('react-native-reanimated');
var _Data = require('./Data');
var _utils = require('./utils');
function _interopRequireWildcard(e, t) {
  if ('function' == typeof WeakMap)
    var r = new WeakMap(),
      n = new WeakMap();
  return (_interopRequireWildcard = function (e, t) {
    if (!t && e && e.__esModule) return e;
    var o,
      i,
      f = { __proto__: null, default: e };
    if (null === e || ('object' != typeof e && 'function' != typeof e))
      return f;
    if ((o = t ? n : r)) {
      if (o.has(e)) return o.get(e);
      o.set(e, f);
    }
    for (const t in e)
      'default' !== t &&
        {}.hasOwnProperty.call(e, t) &&
        ((i =
          (o = Object.defineProperty) &&
          Object.getOwnPropertyDescriptor(e, t)) &&
        (i.get || i.set)
          ? o(f, t, i)
          : (f[t] = e[t]));
    return f;
  })(e, t);
}
const LineChartContext = (exports.LineChartContext = /*#__PURE__*/ (0,
_react.createContext)({
  currentX: {
    value: -1,
  },
  currentIndex: {
    value: -1,
  },
  domain: [0, 0],
  isActive: {
    value: false,
  },
  yDomain: {
    min: 0,
    max: 0,
  },
  xDomain: undefined,
  xLength: 0,
}));
function LineChartProvider({
  children,
  data = [],
  yRange,
  onCurrentIndexChange,
  xLength,
  xDomain,
}) {
  const currentX = (0, _reactNativeReanimated.useSharedValue)(-1);
  const currentIndex = (0, _reactNativeReanimated.useSharedValue)(-1);
  const isActive = (0, _reactNativeReanimated.useSharedValue)(false);
  const domain = (0, _react.useMemo)(
    () =>
      (0, _utils.getDomain)(
        Array.isArray(data) ? data : Object.values(data)[0]
      ),
    [data]
  );
  const values = (0, _react.useMemo)(
    () => (0, _utils.lineChartDataPropToArray)(data).map(({ value }) => value),
    [data]
  );
  const yDomainValues = (0, _react.useMemo)(
    () => ({
      min: yRange?.min ?? Math.min(...values),
      max: yRange?.max ?? Math.max(...values),
    }),
    [values, yRange?.min, yRange?.max]
  );
  const contextValue = (0, _react.useMemo)(() => {
    const domainRows = Array.isArray(data) ? data : Object.values(data)[0];
    return {
      currentX,
      currentIndex,
      isActive,
      domain,
      yDomain: yDomainValues,
      xDomain,
      xLength: xLength ?? domainRows.length,
    };
  }, [
    currentIndex,
    currentX,
    data,
    domain,
    isActive,
    yDomainValues,
    xLength,
    xDomain,
  ]);
  (0, _reactNativeReanimated.useAnimatedReaction)(
    () => currentIndex.value,
    (x, prevX) => {
      if (x !== prevX && onCurrentIndexChange) {
        (0, _reactNativeReanimated.runOnJS)(onCurrentIndexChange)(x);
      }
    },
    [currentIndex]
  );
  return /*#__PURE__*/ _react.default.createElement(
    _Data.LineChartDataProvider,
    {
      data: data,
    },
    /*#__PURE__*/ _react.default.createElement(
      LineChartContext.Provider,
      {
        value: contextValue,
      },
      children
    )
  );
}
LineChartProvider.displayName = 'LineChartProvider';
//# sourceMappingURL=Context.js.map
